// src/misc.ts
var sortObjectByKeys = (obj) => {
  const sortedEntries = Object.entries(obj).sort(
    (a, b) => a[0].localeCompare(b[0])
  );
  sortedEntries.forEach(([key, value], index) => {
    if (value && typeof value === "object" && !Array.isArray(value)) {
      sortedEntries[index] = [key, sortObjectByKeys(value)];
    }
  });
  return Object.fromEntries(sortedEntries);
};
var isPlainObject = (value) => {
  if (typeof value !== "object" || value === null) return false;
  return Object.prototype.toString.call(value) === "[object Object]";
};
var immut = (value) => {
  if (isPlainObject(value)) {
    const copiedObj = { ...value };
    const newObj = {};
    Object.keys(copiedObj).forEach((key) => {
      newObj[key] = immut(copiedObj[key]);
    });
    return Object.freeze(newObj);
  }
  if (Array.isArray(value)) {
    const copiedArr = [...value];
    const newArr = [];
    copiedArr.forEach((item) => {
      newArr.push(immut(item));
    });
    return newArr;
  }
  return value;
};
var newVal = (oldVal) => {
  if (isPlainObject(oldVal)) {
    const copiedObj = { ...oldVal };
    const newObj = {};
    Object.keys(copiedObj).forEach((key) => {
      newObj[key] = newVal(copiedObj[key]);
    });
    return newObj;
  }
  if (Array.isArray(oldVal)) {
    const copiedArr = [...oldVal];
    const newArr = [];
    copiedArr.forEach((item) => {
      newArr.push(newVal(item));
    });
    return newArr;
  }
  const value = oldVal;
  return value;
};

// src/equal.ts
var areObjectsEqual = (obj1, obj2) => {
  const sortedObj1 = sortObjectByKeys(obj1);
  const sortedObj2 = sortObjectByKeys(obj2);
  const keys1 = Object.keys(sortedObj1);
  const keys2 = Object.keys(sortedObj2);
  if (keys1.length !== keys2.length) return false;
  for (const key of keys1) {
    if (!keys2.includes(key) || !areValuesEqual(sortedObj1[key], sortedObj2[key])) {
      return false;
    }
  }
  return true;
};
var areArraysEqual = (array1, array2) => {
  if (array1.length !== array2.length) return false;
  if (array1.length === 0) return true;
  for (let i = 0; i < array1.length; i++) {
    if (!areValuesEqual(array1[i], array2[i])) return false;
  }
  return true;
};
var areValuesEqual = (value1, value2) => {
  if (typeof value1 !== typeof value2) return false;
  if (Array.isArray(value1)) {
    return areArraysEqual(value1, value2);
  }
  if (value1 === null || value2 === null) {
    return value1 === value2;
  }
  if (typeof value1 === "object" && !(value1 instanceof Set)) {
    return areObjectsEqual(value1, value2);
  }
  if (typeof value1 === "bigint" || typeof value1 === "number" || typeof value1 === "string" || typeof value1 === "boolean") {
    return value1 === value2;
  }
  return value1 === value2;
};

// src/diff.ts
var getArrUpdateOperations = (oldArray, newArray) => {
  const oldArr = newVal(oldArray);
  const newArr = newVal(newArray);
  const operations = [];
  newArr.forEach((newItem, newIndex) => {
    const newItemValue = { ...newItem, _index: void 0 };
    const foundMatch = oldArr.some((oldItem, oldIndex) => {
      const oldItemValue = { ...oldItem, _index: void 0 };
      if (newItem._index === oldItem._index) {
        if (areValuesEqual(oldItemValue, newItemValue)) {
          operations.push({
            type: "idle",
            value: { ...newItemValue, _index: newIndex },
            oldIndex: oldItem._index
          });
        } else {
          operations.push({
            type: "update",
            value: { ...newItemValue, _index: newIndex },
            oldIndex: oldItem._index
          });
        }
        oldArr.splice(oldIndex, 1);
        return true;
      }
      return false;
    });
    if (!foundMatch)
      operations.push({
        type: "add",
        value: { ...newItemValue, _index: newIndex }
      });
  });
  oldArr.forEach(
    (oldItem, oldIndex) => operations.push({
      type: "delete",
      value: { ...oldItem, _index: 0 - oldArr.length + oldIndex },
      oldIndex: oldItem._index
    })
  );
  return operations.sort((a, b) => a.value._index - b.value._index);
};
export {
  areArraysEqual,
  areObjectsEqual,
  areValuesEqual,
  getArrUpdateOperations,
  immut,
  isPlainObject,
  newVal,
  sortObjectByKeys
};
