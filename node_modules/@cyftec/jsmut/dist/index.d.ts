type IndexedArrObjItem<T extends object> = {
    _index: number;
} & T;
type IndexedArrItem<T extends object> = IndexedArrObjItem<T>;
type IndexedArrItemWoIndex<T extends object> = T & {
    _index: undefined;
};
type IndexedArr<T extends object> = IndexedArrItem<T>[];
type ArrItemOperation<T extends object> = {
    type: "add" | "update" | "delete" | "idle";
    value: IndexedArrObjItem<T>;
    oldIndex?: number;
};

/**
 * This method calculates and returns the mutations in an array if any
 * @param oldArray old value of array going to be mutated
 * @param newArray new mutated value of the old array
 * @returns the list mutations in the old array
 */
declare const getArrUpdateOperations: (oldArray: IndexedArr<any>, newArray: IndexedArr<any>) => ArrItemOperation<any>[];

/**
 * This method only check equality of values of both input objects
 * The input object don't necessarily need to hold the same reference
 * @param obj1
 * @param obj2
 * @returns boolean, if both obj1 and obj2 have same values to the deepest level or not
 */
declare const areObjectsEqual: (obj1: object, obj2: object) => boolean;
/**
 *
 * @param array1
 * @param array2
 * @returns boolean, if the values in both input arrays are equal or not
 */
declare const areArraysEqual: <T>(array1: T[], array2: T[]) => boolean;
/**
 *
 * @param value1
 * @param value2
 * @returns  boolean, if the values in both input values are equal or not, even if datatype of values are mutable
 */
declare const areValuesEqual: (value1: any, value2: any) => boolean;

/**
 *
 * @param obj Object with keys in unsorted order
 * @returns the new Object with same value but sorted keys
 */
declare const sortObjectByKeys: (obj: object) => object;
/**
 *
 * @param value which needs to be checked if it's a plain object or not
 * @returns a boolean denoting if the value is really an object (but not 'null' or 'set')
 */
declare const isPlainObject: (value: any) => boolean;
/**
 *
 * @param value which need to be freezed to prevent mutation
 * @returns a new immuatble copy of input value
 */
declare const immut: <T>(value: T) => T;
/**
 *
 * @param oldVal from which a new copy will be created
 * @returns a new (non-mutated) copy of the (input) oldValue
 */
declare const newVal: <T>(oldVal: T) => T;

export { type ArrItemOperation, type IndexedArr, type IndexedArrItem, type IndexedArrItemWoIndex, type IndexedArrObjItem, areArraysEqual, areObjectsEqual, areValuesEqual, getArrUpdateOperations, immut, isPlainObject, newVal, sortObjectByKeys };
